\documentclass[14pt, a4paper]{extarticle}

\usepackage{my_GOST}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{array}
\usepackage{caption}
\hypersetup{
	pdftex,
	colorlinks = true,
	linkcolor = black,
	filecolor = magenta,
	citecolor = green,      
	urlcolor = cyan,
}

% к таблице и листингу подпись сверху, перед каждым иллюстративным материалом анонсировать
% написатьт в квадратных скобках к рекурсии комментарием что это метод и понятно почему вызываем его снова
\definecolor{mylightgray}{RGB}{240,240,240}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
	backgroundcolor=\color{mylightgray},rulecolor=\color{red},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=t,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	extendedchars=false,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=0,                % start line enumeration with line 1000
	frame=shadowbox,
	%rulesepcolor=\color{green},	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue}\textbf,       % keyword style
	language=C++,                 % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\scriptsize\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage{YATPR}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{float}

\begin{document}
\include{title}

\setcounter{page}{2}

\section{Задание}



Дана концептуальная модель парковки торгового центра, где также предоставляется услуга автомойки: 
\begin{itemize}
	\item количество мест на парковке $\textit{parking\_spaces}=50$;
	\item количество мест для автомойки $\textit{n\_washers}=5$;
	
	\item количество клиентов, которые приезжают на парковку каждую минуту, распределенно по закону Пуассона с параметром $\textit{requests\_lambda}=3$;
	\item вероятность того, что владелец обратится за услугой мойки автомобиля $\textit{washing\_py}=0.1$;
	\item клиент встает в очередь либо к оператору автомойки, либо к оператору парковки, в зависимости от того, требуется ему услуга мойки или нет;

	\item если клиент встал в очередь к оператору парковки, и длина этой очереди больше $\textit{max\_operator\_parking\_len}=30$, то клиент расстраивается и уезжает, иначе ожидает в очереди;
	\item оператор парковки может начать печатать талон для текущего клиента, только если на парковке есть свободное место, оператор парковки обрабатывает одного клиента за $2\pm1$ минуту;
	
	\item если клиент встал в очередь к оператору мойки, и длина этой очереди больше $\textit{max\_operator\_washing\_len}=5$, то клиент расстраивается и уезжает, иначе ожидает в очереди;
	\item оператор мойки может начать печатать талон для текущего клиента, если есть свободное место на автомойке (тогда клиент сразу отправляется на автомойку) или если есть свободное место на парковке (тогда клиент занимает место на парковке и ставится в очередь на автомойку), оператор автомойки обрабатывает одного клиента за $2\pm1$ минуту;
	

	\item мойка одного автомобиля занимает $60\pm20$ минут;
	\item если клиенту не требуется автомойка, значит он идет в торговый центр и проводит там время, распределенное по нормальному закону с параметрами $m=150$ минут и $\sigma=10$;
		

	\item когда услуга автомойки завершена или клиент вернулся из торгового центра, клиент освобождает парковочное место и встает в очередь к оператору оплаты, оператор оплаты обрабатывает одного клиента за $3\pm1$ минуту;
	
\end{itemize}

За единицу имитационного времени принять 0.01 минуты.

Промоделировать процесс обработки 10000 клиентов. Определить имитационное время моделирования; процент клиентов, которым потребовалась услуга автомойки; проценты клиентов, которые отказались от услуг парковки и автомойки; максимальную очередь на оплату.

Также провести моделирование при изменении отдельных параметров модели.

Построить структурную схему модели, а также схему модели в терминах систем массового обслуживания (СМО).




\section{Теоретическая часть}


В процессе взаимодействия клиентов с парковкой с услугой автомойки возможны два режима работы.
\begin{enumerate}
	\item Режим нормального обслуживания: клиент получает требуемую услугу.
	\item Режим отказа от услуги: если очередь превышает предельно допустимую.
\end{enumerate}


\textbf{Эндогенные переменные}: количество парковочных мест, время обработки клиентов операторами; длины очередей, при которых клиенты отказываются от услуг; время, которое клиенты проводят в торговом центре; время мойки автомобиля.

\textbf{Экзогенные переменные}: $p_0$ -- число клиентов, которые припарковались и сходили в торговый центр, $p_1$ -- число  клиентов, которые решили не дожидаться освобождения мест для парковки; $w_0$ -- число клиентов, которые получили услугу автомойки, $w_1$ -- число  клиентов, которые решили не дожидаться освобождения мест для автомойки.

\textbf{Уравнения модели:} 
\begin{itemize}
	\item процент клиентов, которым потребовалась услуга автомойки:
	\begin{equation}
		w = \frac{w_0 + w_1}{p_0 + p_1 + w_0 + w_1};
	\end{equation}

	\item процент клиентов, которые отказались от услуг парковки:
\begin{equation}
	p_{\textit{p}} = \frac{p_1}{p_0 + p_1};
\end{equation}

	\item процент клиентов, которые отказались от услуг автомойки:
\begin{equation}
	p_{\textit{w}} = \frac{w_1}{w_0 + w_1};
\end{equation}
\end{itemize}



Структурная схема модели приведена на рисунке~\ref{pic:01}.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.8]{pictures/2-1.pdf}
			\caption{Структурная схема модели}
			\label{pic:01}}
	\end{center}
\end{figure}


Схема модели в терминах СМО приведена на рисунке~\ref{pic:02}.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.8]{pictures/2-2.pdf}
			\caption{Схема модели в терминах СМО}
			\label{pic:02}}
	\end{center}
\end{figure}

\section{Результаты работы программы}
TODO
Для исследования разработанная программа была протестирована при различном числе генерируемых заявок, различных временах генерации заявок, различных временах работы операторов и компьютеров. На рисунке \ref{pic:res} приведена таблица, где описаны параметры и результаты моделирования. В каждом случае изменялось не более одного (указанного в таблице) параметра, остальные сохранялись из условия. Сгенерированные псевдослучайные числа во всех случаях одинаковы. 

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.55]{pictures/res.png}
			\caption{Таблица с результатами исследования программы}
			\label{pic:res}}
	\end{center}
\end{figure}



\section{Код программы}

В листинге \ref{lst:list1} приведен код разработанной программы (используемый язык -- Python). 

\begin{lstlisting}[caption = {Код разработанной программы}, label=lst:list1]
from typing import *
from prettytable import PrettyTable
from random import random, seed
seed(0)

REQUESTS_TO_GENERATE = 300
MOD_TIME_STEP = 0.01

CLIENT_TIMES = [8, 12]
O1_TIMES = [15, 25]
O2_TIMES = [30, 50]
O3_TIMES = [20, 60]
C1_TIME = 15
C2_TIME = 30

ACCUMULATORS = [0, 0]
O1_ACCUM_INDEX = 0
O2_ACCUM_INDEX = 0
O3_ACCUM_INDEX = 1
C1_ACCUM_INDEX = 0
C2_ACCUM_INDEX = 1


class DistributedTimeGenerator:
	def __init__(self, a: float, b: float):
		self.a = a
		self.b = b
	
	def generate(self):
		return self.a + (self.b - self.a) * random()


class RequestsGenerator:
	def __init__(self, time_generator: DistributedTimeGenerator):
		self.time_generator = time_generator
		self.remaining_time = 0
	
	def update_time_and_check_for_request(self):
		if self.remaining_time > 0:
			self.remaining_time -= MOD_TIME_STEP
			return False
		else:
			self.remaining_time = self.time_generator.generate()
			return True


class Operator:
	def __init__(self, accum_index: int, time_generator: DistributedTimeGenerator):
		self.accum_index = accum_index
		self.time_generator = time_generator
		
		self.is_busy = False
		self.remaining_time = 0
	
	def update_time(self):
		self.remaining_time -= MOD_TIME_STEP
		
		if self.is_busy and self.remaining_time <= 0:
			self.is_busy = False
			ACCUMULATORS[self.accum_index] += 1
	
	def start_process_new_request(self):
		self.is_busy = True
		self.remaining_time = self.time_generator.generate()


class Computer:
	def __init__(self, accum_index: int, processing_time: int):
		self.accum_index = accum_index
		self.processing_time = processing_time
		self.is_busy = False
		self.remaining_time = 0
	
	def update_time_and_check_for_finished_processing(self):
		self.remaining_time -= MOD_TIME_STEP
		
		if self.is_busy:
			if self.remaining_time <= 0:
				self.is_busy = False
				return True
		else:
			if ACCUMULATORS[self.accum_index] > 0:
				ACCUMULATORS[self.accum_index] -= 1
				self.is_busy = True
				self.remaining_time = self.processing_time
		
		return False


def find_free_operator(operators):
	for i in range(len(operators)):
		if not operators[i].is_busy:
			return i


def simulate():
	requests_generator = RequestsGenerator(DistributedTimeGenerator(*CLIENT_TIMES))
	
	operators = [
	Operator(O1_ACCUM_INDEX, DistributedTimeGenerator(*O1_TIMES)),
	Operator(O2_ACCUM_INDEX, DistributedTimeGenerator(*O2_TIMES)),
	Operator(O3_ACCUM_INDEX, DistributedTimeGenerator(*O3_TIMES))
	]
	
	computers = [
	Computer(C1_ACCUM_INDEX, C1_TIME),
	Computer(C2_ACCUM_INDEX, C2_TIME)
	]
	
	generated, processed, rejected, modeling_time = 0, 0, 0, 0
	while processed + rejected < REQUESTS_TO_GENERATE:
		modeling_time += MOD_TIME_STEP
		if generated < REQUESTS_TO_GENERATE:
			request = requests_generator.update_time_and_check_for_request()
			if request:
				generated += 1
				free_operator_index = find_free_operator(operators)
				if free_operator_index is None:
					rejected += 1
				else:
					operators[free_operator_index].start_process_new_request()
		
		for operator in operators:
			operator.update_time()
		
		for computer in computers:
			if computer.update_time_and_check_for_finished_processing():
				processed += 1
	
	return generated, processed, rejected, modeling_time


def main():
	global REQUESTS_TO_GENERATE
	global C2_TIME
	global O1_TIMES
	global CLIENT_TIMES
	
	res_table = PrettyTable()
	res_table.field_names = ['Случай', 'Имитационное время моделирования', 'Вероятность отказа']
	
	seed(0)
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row(['Исходные настройки', modeling_time, round(rejected / generated, 2)])
	
	seed(0)
	mn = 10
	tmp = REQUESTS_TO_GENERATE
	REQUESTS_TO_GENERATE = REQUESTS_TO_GENERATE * mn
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Количество заявок увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	REQUESTS_TO_GENERATE = tmp
	
	seed(0)
	mn = 3
	tmp = C2_TIME
	C2_TIME = C2_TIME * mn
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время 2 компьютера увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	C2_TIME = tmp
	
	seed(0)
	mn = 3
	tmp = O1_TIMES
	O1_TIMES = list(map(lambda time: time * mn, O1_TIMES))
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время 1 оператора увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	O1_TIMES = tmp
	
	seed(0)
	mn = 2
	tmp = CLIENT_TIMES
	CLIENT_TIMES = list(map(lambda time: time // mn, CLIENT_TIMES))
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время генерации заявок уменьшено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	CLIENT_TIMES = tmp

	print(res_table)

if __name__ == '__main__':
	main()
\end{lstlisting}

\end{document}