\documentclass[14pt, a4paper]{extarticle}

\usepackage{my_GOST}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{array}
\usepackage{caption}
\hypersetup{
	pdftex,
	colorlinks = true,
	linkcolor = black,
	filecolor = magenta,
	citecolor = green,      
	urlcolor = cyan,
}

% к таблице и листингу подпись сверху, перед каждым иллюстративным материалом анонсировать
% написатьт в квадратных скобках к рекурсии комментарием что это метод и понятно почему вызываем его снова
\definecolor{mylightgray}{RGB}{240,240,240}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
	backgroundcolor=\color{mylightgray},rulecolor=\color{red},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=t,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	extendedchars=false,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=0,                % start line enumeration with line 1000
	frame=shadowbox,
	%rulesepcolor=\color{green},	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue}\textbf,       % keyword style
	language=C++,                 % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\scriptsize\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage{YATPR}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{float}

\begin{document}
\include{title}

\setcounter{page}{2}

\section{Задание}



Дана концептуальная модель информационного центра: 
\begin{itemize}
	\item в информационный центр приходят клиенты через интервалы времени $10\pm2$ минуты; если все три имеющихся оператора заняты, клиенту отказывают в  обслуживании;
	\item операторы имеют разную производительность и могут  обеспечивать обслуживание среднего запроса пользователя за $20\pm5$, $40\pm10$, $40\pm20$ минут; клиенты стремятся занять свободного оператора с максимальной производительностью;
	\item полученные запросы попадают в приемный накопитель, откуда они выбираются на обработку;
	\item на первый компьютер поступают запросы от 1-ого и 2-ого операторов, на второй – от 3-его; время обработки запросов на первом и втором компьютерах равно, соответственно, 15 и 30 минутам. 
\end{itemize}

За единицу имитационного времени принять 0.01 минуты.

Промоделировать процесс обработки 300 запросов. Определить вероятность отказа. Построить структурную схему модели, а также схему модели в терминах систем массового обслуживания (СМО).





\section{Теоретическая часть}


В процессе взаимодействия клиентов с информационным центром возможны два режима работы.
\begin{enumerate}
	\item Режим нормального обслуживания: клиент выбирает одного из  свободных операторов (c максимальной производительностью).
	\item Режим отказа в обслуживании: если все операторы заняты.
\end{enumerate}



\textbf{Эндогенные переменные}: время обработки задания i-ым оператором,  время решения задания на j-ом компьютере.

\textbf{Экзогенные переменные}: $n_0$ -- число обслуженных клиентов, $n_1$ -- число  клиентов, получивших отказ.

\textbf{Уравнение модели} (вероятность отказа в обслуживании клиента):
\begin{equation}
	p_{\textit{отк}} = \frac{n_1}{n_0+n_1}.
\end{equation}

Структурная схема модели приведена на рисунке~\ref{pic:01}.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.85]{pictures/1.pdf}
			\caption{Структурная схема модели}
			\label{pic:01}}
	\end{center}
\end{figure}


Схема модели в терминах СМО приведена на рисунке~\ref{pic:02}.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.85]{pictures/2.pdf}
			\caption{Схема модели в терминах СМО}
			\label{pic:02}}
	\end{center}
\end{figure}

\section{Результаты работы программы}

Для исследования разработанная программа была протестирована при различном числе генерируемых заявок, различных временах генерации заявок, различных временах работы операторов и компьютеров. На рисунке \ref{pic:res} приведена таблица, где описаны параметры и результаты моделирования. В каждом случае изменялось не более одного (указанного в таблице) параметра, остальные сохранялись из условия. Сгенерированные псевдослучайные числа во всех случаях одинаковы. 

\begin{figure}[h]
	\begin{center}
		{\includegraphics[scale=0.75]{pictures/res.png}
			\caption{Таблица с результатами исследования программы}
			\label{pic:res}}
	\end{center}
\end{figure}



\section{Код программы}

В листинге \ref{lst:list1} приведен код разработанной программы (используемый язык -- Python). 

\begin{lstlisting}[caption = {Код разработанной программы}, label=lst:list1]
from typing import *
from prettytable import PrettyTable
from random import random, seed
seed(0)

REQUESTS_TO_GENERATE = 300
MOD_TIME_STEP = 0.01

CLIENT_TIMES = [8, 12]
O1_TIMES = [15, 25]
O2_TIMES = [30, 50]
O3_TIMES = [20, 60]
C1_TIME = 15
C2_TIME = 30

ACCUMULATORS = [0, 0]
O1_ACCUM_INDEX = 0
O2_ACCUM_INDEX = 0
O3_ACCUM_INDEX = 1
C1_ACCUM_INDEX = 0
C2_ACCUM_INDEX = 1


class DistributedTimeGenerator:
	def __init__(self, a: float, b: float):
		self.a = a
		self.b = b
	
	def generate(self):
		return self.a + (self.b - self.a) * random()


class RequestsGenerator:
	def __init__(self, time_generator: DistributedTimeGenerator):
		self.time_generator = time_generator
		self.remaining_time = 0
	
	def update_time_and_check_for_request(self):
		if self.remaining_time > 0:
			self.remaining_time -= MOD_TIME_STEP
			return False
		else:
			self.remaining_time = self.time_generator.generate()
			return True


class Operator:
	def __init__(self, accum_index: int, time_generator: DistributedTimeGenerator):
		self.accum_index = accum_index
		self.time_generator = time_generator
		
		self.is_busy = False
		self.remaining_time = 0
	
	def update_time(self):
		self.remaining_time -= MOD_TIME_STEP
		
		if self.is_busy and self.remaining_time <= 0:
			self.is_busy = False
			ACCUMULATORS[self.accum_index] += 1
	
	def start_process_new_request(self):
		self.is_busy = True
		self.remaining_time = self.time_generator.generate()


class Computer:
	def __init__(self, accum_index: int, processing_time: int):
		self.accum_index = accum_index
		self.processing_time = processing_time
		self.is_busy = False
		self.remaining_time = 0
	
	def update_time_and_check_for_finished_processing(self):
		self.remaining_time -= MOD_TIME_STEP
		
		if self.is_busy:
			if self.remaining_time <= 0:
				self.is_busy = False
				return True
		else:
			if ACCUMULATORS[self.accum_index] > 0:
				ACCUMULATORS[self.accum_index] -= 1
				self.is_busy = True
				self.remaining_time = self.processing_time
		
		return False


def find_free_operator(operators):
	for i in range(len(operators)):
		if not operators[i].is_busy:
			return i


def simulate():
	requests_generator = RequestsGenerator(DistributedTimeGenerator(*CLIENT_TIMES))
	
	operators = [
	Operator(O1_ACCUM_INDEX, DistributedTimeGenerator(*O1_TIMES)),
	Operator(O2_ACCUM_INDEX, DistributedTimeGenerator(*O2_TIMES)),
	Operator(O3_ACCUM_INDEX, DistributedTimeGenerator(*O3_TIMES))
	]
	
	computers = [
	Computer(C1_ACCUM_INDEX, C1_TIME),
	Computer(C2_ACCUM_INDEX, C2_TIME)
	]
	
	generated, processed, rejected, modeling_time = 0, 0, 0, 0
	while processed + rejected < REQUESTS_TO_GENERATE:
		modeling_time += MOD_TIME_STEP
		if generated < REQUESTS_TO_GENERATE:
			request = requests_generator.update_time_and_check_for_request()
			if request:
				generated += 1
				free_operator_index = find_free_operator(operators)
				if free_operator_index is None:
					rejected += 1
				else:
					operators[free_operator_index].start_process_new_request()
		
		for operator in operators:
			operator.update_time()
		
		for computer in computers:
			if computer.update_time_and_check_for_finished_processing():
				processed += 1
	
	return generated, processed, rejected, modeling_time


def main():
	global REQUESTS_TO_GENERATE
	global C2_TIME
	global O1_TIMES
	global CLIENT_TIMES
	
	res_table = PrettyTable()
	res_table.field_names = ['Случай', 'Имитационное время моделирования', 'Вероятность отказа']
	
	seed(0)
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row(['Исходные настройки', modeling_time, round(rejected / generated, 2)])
	
	seed(0)
	mn = 10
	tmp = REQUESTS_TO_GENERATE
	REQUESTS_TO_GENERATE = REQUESTS_TO_GENERATE * mn
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Количество заявок увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	REQUESTS_TO_GENERATE = tmp
	
	seed(0)
	mn = 3
	tmp = C2_TIME
	C2_TIME = C2_TIME * mn
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время 2 компьютера увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	C2_TIME = tmp
	
	seed(0)
	mn = 3
	tmp = O1_TIMES
	O1_TIMES = list(map(lambda time: time * mn, O1_TIMES))
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время 1 оператора увеличено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	O1_TIMES = tmp
	
	seed(0)
	mn = 2
	tmp = CLIENT_TIMES
	CLIENT_TIMES = list(map(lambda time: time // mn, CLIENT_TIMES))
	generated, processed, rejected, modeling_time = simulate()
	print(generated, processed, rejected, modeling_time)
	res_table.add_row([f'Время генерации заявок уменьшено в {mn} раза', modeling_time, round(rejected / generated, 2)])
	CLIENT_TIMES = tmp

	print(res_table)

if __name__ == '__main__':
	main()
\end{lstlisting}

\end{document}